# 파일과 디렉토리란? #

**파일(File)** 은 의미가 있는 정보를 모아둔 논리적인 단위로 종이 문서의 묶음을 말하는 파일에서 유래한 용어임. 텍스트 파일, 실행 파일, 이미지 파일 등 목적에 따라 다양한 파일들이 존재하며 각 파일의 이름은 일반적으로 `<파일이름>.<확장자명>`으로 구성됨. 확장자(예: .exe, .png, .docx 등)로 파일의 종류를 GUI로 보여주는 macOS나 Windows와 달리 CLI 환경에서는 확장자가 큰 상관이 없음. 또한 운영체제는 파일의 맨 처음 특정 bytes만큼을 읽어 구분하기 때문에 반드시 확장자명을 설정할 필요가 없음. 파일의 맨 앞에 특정한 바이트로 해당 파일의 종류를 나타내는 값을 **매직 넘버(Magic Number)** 혹은 **파일 시그니처(File Signature)** 라 부름

예를 들어, Windows에서는 `report.docx`라는 파일이 있으면 확장자인 .docx를 보고 워드 문서로 인식함. 하지만 리눅스에서는 확장자가 없어도 파일 내부 데이터를 확인해 워드 문서인지 판별하기 때문에 파일 이름에 .docx라는 확장자가 없어도 워드 문서로 인식할 수 있음

리눅스에서 확장자가 필수는 아니지만 파일 이름만 보고 쉽게 구분할 수 있도록 .sh(셸 스크립트), .log(로그 파일) 같은 확장자를 붙이는 것이 일반적임

**디렉토리(Directory)** 는 파일을 분류하기 위해 사용하는 **네임스페이스(Namespace)** 이며 Windows와 같은 환경에서는 주로 폴더라고 부름.
디렉토리는 다른 디렉토리 혹은 파일을 내부에 포함할 수 있으며 이때 포함되는 디렉토리는 **하위 디렉토리(Child Directory/Sub Directory)** 라 부름. 하위 디렉토리를 포함하는 디렉토리는 하위 디렉토리 관점에서 위에 있으므로 **상위 디렉토리(Parent Directory)** 라 부름. 리눅스에서는 디렉토리를 특수한 파일로 취급하여 관리함. 디렉토리와 파일들은 일반적으로 트리 구조를 형성함

![[Pasted image 20260130171718.png]]

| 디렉토리 경로     | 목적                                                        |
| ----------- | --------------------------------------------------------- |
| /bin        | 기본 실행 프로그램 저장                                             |
| /boot       | 리눅스 커널과 부트로더 저장                                           |
| /dev        | 디바이스 장치 파일                                                |
| /etc        | 시스템 환경 설정 파일 저장                                           |
| /home       | 사용자 별 홈 디렉토리 담는 디렉토리                                      |
| /lib        | 공유 라이브러리 파일 저장                                            |
| /lost+found | 부팅 시 파일 시스템에 문제가 생기는 경우 복구에 사용하기 위함                       |
| /media      | 물리적 저장 장치들을 **마운트(Mount)** 하기 위해 사용                       |
| /mnt        | 물리적 저장 장치들을 **마운트(Mount)** 하기 위해 사용                       |
| /opt        | 추가적인 프로그램들을 설치하기 위해 사용                                    |
| /proc       | 커널 관련 정보를 저장하기 위한 디렉토리이며, 현재 실행되고 있는 시스템의 모든 프로세스 정보가 보관됨 |
| /root       | 루트(최고 관리자)의 홈 디렉토리. 일반 사용자와 홈 디렉토리가 분리되어 있음               |
| /sbin       | 시스템 관리자를 위한 프로그램 저장                                       |
| /srv        | 서버 시스템에서 사용되는 데이터 저장                                      |
| /tmp        | 임시 파일 저장                                                  |
| /usr        | 사용자 어플리케이션들을 지원하기 위한 파일들을 저장                              |
| /var        | 로그 파일 저장                                                  |

최상위 디렉토리는 /로 표기하며 그 하위 디렉토리는 `/<directory 1>` , 그 하위 디렉토리는 `/<directory 1>/<directory 2>` 와 같이 표기함. 어떤 폴더나 디렉토리의 경로를 최상위 디렉토리부터 표시한 경로를 **절대 경로**라 부름

반면 사용한 경로가 `/`부터 시작하지 않은 경우 **상대 경로**라 부름

상대 경로는 크게 `./` 와 `~/` 로 시작함 `./`은 현재 사용자가 위치한 디렉토리의 위치를 의미하며 `~/`는 사용자의 홈 디렉토리를 의미함. 
예를 들어 사용자의 홈 디렉토리가 `/home/user` 이고 접근하고자 하는 디렉토리가 `/home/user/aaaa` 라면 `~/aaaa` 로 표기할 수 있음. `./`도 동일한 식으로 사용할 수 음

추가적으로 `../` 와 같이 점을 2번 쓰면 상위 디렉토리를 의미함



---
# 디렉토리 경로 확인 및 변경 #

## 디렉토리 경로 확인(pwd) ##

사용자가 터미널을 켜면 항상 어떤 디렉토리 위에 있으며 특별한 설정을 하지 않으면 기본적으로 자신의 홈 디렉토리에 위치하게 됨. 터미널을 켜는 순간 `~`는 표기가 나오는 모습을 확인할 수 있으며 앞에서 살펴보았듯 현재 자신의 위치가 홈 디렉터리임을 의미함

`pwd`는 print working directory의 약자로 **현재 작업중인 디렉토리를 출력**하는 명령어

현재 자신의 경로를 확인하기 위해서는 `pwd`명령어를 사용해야함. 아래 사진과 같이 터미널에 `pwd`를 입력하면 현재 작업중인 디렉터리의 위치를 출력함

![[Pasted image 20260205174236.png]]


---
## 디렉토리 경로 확인(pwd) ##
cd는 **c**hange **d**irectory의 약자로 디렉토리 경로를 변경할 때 사용함. 앞에서 절대 경로와 상대 경로를 봤는데 이 때 상위 디렉토리의 경로를 **../** 라 부른다는 것을 알아봤으니까 현재 디렉토리에서 상위 디렉토리로 이동하고 싶으면 **cd ../** 를 입력하면 경로를 변경할 수 있음

아래 사진은 **cd ../** 로 경로를 변경하고 **pwd**명령으로 변경된 경로를 출력한 결과임. **/home/user** 에서 **/home**으로 이동한 모습을 확인할 수 있음

![[Pasted image 20260205174302.png]]

아래와 같이 상대경로만이 아닌 절대경로로도 이동할 수 있음. **cd /home**을 하면 동일하게 **/home**으로 이동할 수 있고, **cd**만 입력해도 홈 디렉토리로 이동할 수 있음
![[Pasted image 20260205174320.png]]



---
# 디렉토리 생성 및 삭제 #

## 디렉토리 및 파일 확인(ls) ##

`ls`는 **l**ist **s**egments의 약자로 파일 목록을 표시함

`ls` 명령어를 이용하여 생성된 디렉토리나 파일을 확인할 수 있으며 구체적인 옵션들은 `ls --help`를 이용하여 확인할 수 있음. 이중 자주 사용하는 옵션들은 아래와 같고 명령어 뒤에 붙여서 사용할 수 있음

| 옵션(대소문자 따짐) | 기능                                 |
| ----------- | ---------------------------------- |
| -a          | 모든 파일 출력                           |
| -l          | Long Listing Format으로 출력           |
| -Z          | Selinux 정보 출력                      |
| -s          | 파일 크기 출력                           |
| -S          | 파일 크기 순으로 출력                       |
| -h          | 파일 크기 정보를 Kbytes, Mbytes 등의 단위로 표현 |
| -i          | 파일의 인덱스 넘버 표시                      |
| -R          | 하위 디렉토리를 포함한 모든 내용 출력              |

주로 `ls [옵션] [파일 경로]` 형태로 사용하며 파일 경로를 명시하지 않은 경우 현재 디렉토리의 파일들을 확인함.
아래 사진은 `-a`옵션과 `-l`옵션을 동시에 사용한 `ls -al` 명령어를 실행한 결과로 *현재 디렉토리에 존재하는 모든 파일 및 디렉토리들을 확인*할 수 있음

![[Pasted image 20260205175012.png]]

출력된 결과 중 한 줄의 내용 설명
![[Pasted image 20260205175303.png]]


## ※ ls 명령어의 출력 결과를 설명할 때 디렉토리임에도 왜 파일이라는 용어를 사용하는가 ##

사용자가 사용하는 셸 명령어 또는 프로그램들은 파일과 디렉토리를 엄격히 구분하여 사용하는 경우가 많음. 하지만 리눅스 커널은 내부적으로 파일과 디렉토리를 같은 구조체를 사용해 관리하기 때문에 커널 레벨에서는 파일과 디렉토리를 크게 구분하지 않고, 둘 모두 파일의 한 종류로 취급함

권한 정보는 커널 레벨의 내용을 참조하기 때문에 앞의 파일 종류를 알려주는 플래그를 붙여 유저에게 해당 파일이 어떤 타입인지 보여주는 것이며 유저는 해당 정보를 보고 파일과 디렉토리를 구분해야함



---
## 디렉토리 생성(mkdir) ##
`mkdir`은 **m**a**k**e **dir**ectory의 약자로, 새로운 디렉토리를 생성함. `mkdir [디렉토리 이름]`과 같이 사용함

`/root/SakJae` 폴더로 이동 후 `mkdir file_and_directory`를 사용함. 그리고 `ls`를 입력하면 새로운 디렉토리가 생성된 것이 확인가능함
이후 `cd file_and_directory` 명령으로 폴더 안으로 들어간 후 `mkdir dir1`을 하면 `file_and_directory` 디렉토리 안에 `dir1`이 생성된 것을 확인할 수 있음

![[Pasted image 20260206091758.png]]



---
## 디렉토리 삭제(rmdir) ##
`rmdir`은 **r**e**m**ove **dir**ectory의 약자로, 생성된 디렉토리를 삭제함. `rmdir [디렉토리 이름]`과 같이 사용함

![[Pasted image 20260206092024.png]]



---
# 파일 생성, 이동, 변경 및 삭제 #

## 파일 생성 (touch) ##

리눅스에서 파일을 생성하는 방법은 매우 다양함. 지금 배울 `touch`뿐만 아니라 다음 페이지에서 학습할 `cat`, 리눅스에서 많이 사용되는 텍스트 편집기인 `vim`으로도 파일을 생성할 수 있음

`touch`는 말 그대로 **touch**의 의미를 가지고 있으며 생성되지 않은 파일에 접근할 때와 생성되지 않을 때의 역할이 다름. 본 강의에서는 파일 생성 목적으로의 `touch`를 다룸

일반적으로는 `touch [파일 이름]`으로 새로운 파일을 생성하며, 이때 파일의 크기는 0임. 여러 개의 파일을 한 번에 생성하고 싶은 경우에는 `touch [파일 이름1] [파일 이름2] ...`와 같이 사용함

![[Pasted image 20260206093906.png]]


---
## 파일 읽기 및 쓰기 (cat, head, tail) ##

`touch`로는 파일에 내용을 읽거나 쓸 수 없음. 일반적으로 파일에 내용을 쓰기 위해서는 `cat`같은 명령어나 `vim`같은 텍스트 편집기를 사용해야함

`cat`은 **c**onc**at**enate에서 유래한 명령어로 단어의 뜻에서 보이듯이 `cat`은 두 내용을 연결한다는 뜻을 가지고 있음. 만약 `cat [파일 이름]`을 입력하면 파일과 터미널 입출력을 연결하게 되며 파일의 내용이 터미널에 출력됨

반대로 `cat > [파일 이름]`을 입력하면 (예: `cat > file1`) 터미널의 입출력과 파일을 연결하게 되며 터미널의 입력이 파일에 기록됨. 일단 지금은 `>`를 이정도의 의미로만 이해하고 넘어가도록

`cat > file1 << EOF`를 입력하고 아래 내용을 입력

```
Hello, Linux!
EOF

```

원래 file1의 용량이 0에서 14로 입력한 문자열(Hello, Linux! + (개행 문자))의 길이만큼 변경된 것을 확인할 수 있음
 (\* **리눅스에서 텍스트 파일의 한 줄은 반드시 마지막에 개행 문자를 포함하기 때문에, 글자수보다 1바이트 늘어나게됨**)

![[Pasted image 20260206102158.png]]


`cat`으로 파일의 내용을 읽을 수도 있음

![[Pasted image 20260206102914.png]]


`cat`만이 아니라 `head`, `tail`과 같은 명령어들로도 파일을 읽을 수 있음. `head`는 파일의 앞쪽을 읽는 명령어이고, `tail`은 파일의 뒤쪽을 읽는 명령어임. `-c [bytes]` 옵션을 사용하여 원하는 바이트만큼 읽어오거나 `-n [개수]` 옵션을 사용하여 원하는 줄 수 만큼 읽어올 수 있음

`head -c 5 file1`을 사용하면 파일의 앞 5글자를 읽어옴
 
![[Pasted image 20260206103435.png]]


`tail -c 5 file1`을 사용하면 파일의 앞 5글자를 읽어옴

![[Pasted image 20260206103625.png]]

**출력했을 때 문자열이 특이한 이유**
head를 했을 때는 "Hello" 다음에 바로 root@가 나오는데 왜 이렇냐면 file1의 앞의 5글자인 Hello 다음에 오는 글자는 쉼표(,)로 개행문자가 아니기 때문에 줄바꿈이 안 돼서 Hello와 root@...가 붙어서 나옴

tail을 했을 때는 "nux!"로 4글자만 출력된 이유가 file1의 마지막 5글자가 "nux!\n"로 개행문자까지 포함해서 5글자이기 때문에 nux! 4글자와 개행문자로 인해 줄바꿈이 됐음



---
## 파일 이동 및 복사 (mv, cp) ##

\*실습을 위해 mkdir dir1으로 디렉토리를 하나 생성함

`mv`는 **m**o**v**e의 약자로 파일의 경로를 변경함. 
`mv [옵션] [현재 경로] [변경할 경로]`와 같이 사용하고, `mv`는 디렉토리에도 문제없이 사용할 수 있음

| 옵션  | 기능                                                        |
| --- | --------------------------------------------------------- |
| -b  | 변경하고자 하는 경로에 동일한 파일명이 존재하면 백업 파일을 생성함                     |
| -f  | 변경하고자 하는 경로에 동일한 파일명이 존재하면 사용자에게 덮어씌우기 여부를 묻지 않고 강제로 덮어씌움 |
| -i  | 변경하고자 하는 경로에 동일한 파일명이 존재하면 사용자에게 덮어씌우기 여부를 물어봄            |
| -n  | 변경하고자 하는 경로에 동일한 파일명이 존재하면 파일을 이동하지 않음                    |

`mv file1 dir1/file1`을 입력하면 파일이 dir1으로 이동함

![[Pasted image 20260206105509.png]]


변경할 경로에서 파일명을 지정 안 하고 디렉토리만 입력하면 자동으로 동일한 파일명을 사용함
![[Pasted image 20260206105940.png]]


#### ※ mv를 통해서는 단순히 이동이 아닌 파일명을 바꾸는 것이 가능함 ####

![[Pasted image 20260206110319.png]]

이게 가능한 이유는 mv는 경로를 바꾸는데 사실 파일의 이름이 파일의 경로를 뜻함. 
![[Pasted image 20260206110705.png]]

file_and_directory의 file1과 file_and_directory/dir1의 file1은 이름이 같지 않음 두 파일의 진짜 이름은
- /root/SakJae/file_and_directory/file1
- /root/SakJae/file_and_directory/dir1/file1
으로 파일 이름에 경로를 포함하기 때문에 하나의 OS에 동일한 파일명(경로포함)을 가지는 파일은 없다고 볼 수 있음
따라서 mv로 파일의 경로를 바꾼다는 것은 파일의 이름을 바꾼다는 것으로도 이해가 가능함




 `cp`는 **c**o**p**y의 약자로, 파일을 복사함. 
 `cp [옵션] [현재 경로] [복사할 경로]`와 같이 사용하고, **디렉토리에 `cp`를 사용하기 위해서는 `-r` 옵션을 붙여야함**

| 옵션  | 기능                                                        |
| --- | --------------------------------------------------------- |
| -r  | 하위 디렉토리의 내용까지 모두 복사함                                      |
| -f  | 복사하고자 하는 경로에 동일한 파일명이 존재하면 사용자에게 덮어씌우기 여부를 묻지 않고 강제로 덮어씌움 |
| -i  | 복사하고자 하는 경로에 동일한 파일명이 존재하면 사용자에게 덮어씌우기 여부를 물어봄            |
| -p  | 파일 복사 시 모든 권한 정보를 함께 복사함                                  |

![[Pasted image 20260206111555.png]]


---
## 파일 삭제 (rm) ##

`rm`은 **r**e**m**ove의 약자로 생성된 파일을 삭제함

| 옵션  | 기능                                |
| --- | --------------------------------- |
| -f  | 강제로 파일이나 디렉토리를 삭제함                |
| -r  | 삭제하고자 하는 경로의 하위 객체들을 재귀적으로 모두 삭제함 |
| -d  | 비어있는 디렉토리만 삭제함                    |
| -v  | 삭제되는 대상 정보를 출력함                   |

일반적으로 `rm`은 디렉토리는 지울 수 없음. 따라서 `rm [디렉토리 경로]`를 입력하면 삭제할 수 없다는 경고가 나옴
![[Pasted image 20260206111943.png]]


하지만 `rm -rf dir1`과 같이 `-r`, `-f` 옵션과 함께 사용하면 지울 수 있음. 이렇게하면 쉽게 지울 수 있지만 경로를 잘못 지정하면 하위 디렉토리의 모든 내용을 삭제할 수 있기 때문에 주의해서 써야함

![[Pasted image 20260206113200.png]]

파일은 그냥 `rm [파일 이름]`처럼 간단하게 삭제할 수 있음

![[Pasted image 20260206113259.png]]



---
# 파일 링크 #

## 하드 링크와 심볼릭 링크란? ##

**링크 파일(Link File)** 이란 어떤 파일들의 정보를 직간접적으로 연결한 파일을 의미함. 윈도우의 바로가기는 대표적인 링크 파일의 예시임

#### 리눅스가 파일을 관리하는 방식 ####
운영체제는 파일들을 생성하고, 읽고, 쓰기 위해 관리하는 시스템이 필요하며 이를 **파일 시스템(File System)** 이라 부름. 한 운영체제에서도 여러 개의 파일 시스템을 사용할 수 있으며 대표적으로 **Extended File System(ext)** 시리즈, **New Technology File System (NTFS)**, **Overlay File System (Overlay FS)** 등이 있음. 대부분의 우분투는 **ext** 시리즈 중 하나인 **ext4**를 사용함

리눅스의 파일 시스템은 각 파일들을 **inode**라는 메타 데이터로 관리하며 각 파일은 고유한 **icode**를 단 하나만 가지고 있음. 따라서 어떤 파일도 **inode**를 아예 가지지 않거나 1개보다 많이 가질 수는 없음

**inode**는 아래 정보를 포함함
- inode 번호
- 파일 모드
- 링크 개수
- 소유자와 그룹 ID
- 파일 크기와 주소
- 파일 최종 접근, 수정 정보
- inode 수정 정보
- 데이터 저장 위치

구체적으로는 아래 사진과 같이 파일의 정보를 관리함. 사진의 가장 왼쪽에 있는 구조체가 inode이며 data는 파일이 저장하고 있는 데이터를 의미함

![[Pasted image 20260206132833.png]]


아래 그림은 위 사진의 inode 구조를 간략하게 나타낸 모습임. 참조 **횟수(Reference Count, refcount)** 는 inode를 참조하고 있는 파일의 개수를 의미하고 위 숫자(`19283`)는 inode의 고유 번호를 의미함. 만약 **참조 횟수가 0이라면 프로그램은 해당 객체에 접근하는 다른 객체들이 없는 것으로 판단하고 메모리 상에서 참조 횟수가 0인 객체를 제거함**. refcount가 파일 생성 시 inode 구조체의 초기 상태는 아래와 같음

![[Pasted image 20260206133240.png]]


**하드 링크(Hard Link)** 란 생성되는 파일의 inode를 링크하고자 하는 파일에 직접 연결하는 방식임. 이렇게 연결된 두 파일은 경로만 다를 뿐 사실상 동일한 파일임. 커널에서는 이를 체크하기 위해 inode의 링크 개수를 1 증가시킴. 따라서 원본 파일이 삭제되더라도 하드 링크된 파일은 여전히 링크한 파일의 내용에 접근할 수 있음

아래 그림에서 `파일 A`는 원본 파일이고 `파일 B`는 하드 링크로 생성한 파일임. 아래 그림의 **하드 링크 생성** 파트를 보면 `파일 A`와 `파일 B`가 각자 inode를 참조하고 있으므로 inode의 refcount가 2가 됨

만약 `파일 A`를 삭제하는 경우 inode를 참조하는 객체가 제거되므로 아래 그림의 **원본 파일 삭제**와 같은 상황이 되며 refcount가 1로 줄어듦. 하드 링크로 생성한 `파일 B`는 여전히 inode를 참조하고 있으며 그 inode의 refcount가 0이 아니므로 `파일 A`가 제거되더라도 문제 없이 기존 파일 내용에 접근할 수 있음

![[Pasted image 20260206142259.png]]


**심볼릭 링크(Symbolic Link)** 또는 **소프트 링크(Soft Link)** 란 절대 경로 또는 상대 경로로 된 다른 파일들을 참조하는 파일이며, Winodws의 바로가기와 유사함. 아래 그림과 같이 새로운 **inode**를 생성하고, 그 **inode**가 링크하고자 하는 파일을 가리키는 방식

아래 그림에서 `파일 A`는 원본 파일이고 `파일 B`는 소프트 링크로 생성한 파일임. 하드 링크와 달리 소프트 링크로 생성된 파일인 `파일 B`는 원본 파일의 inode를 직접 가리키지 않음. 대신 고유한 inode를 새로 생성하고 그렇게 생성한 inode가 파일 A를 가리키는 방식임. 이는 아래 그림의 **소프트 링크 생성** 그림과 같음. 각자 inode를 가지고 refcount가 1인 점이 하드링크와는 다름

만약 원본 파일인 `파일 A`를 제거하게 되면 `파일 B`는 삭제된 파일을 참조하고 있으므로 아래 그림의 **원본 파일 삭제**와 동일한 상황이 되며 더 이상 원본 파일의 내용에 접근할 수 없음

![[Pasted image 20260206161801.png]]

이게 맞는지는 모르겠지만 일단 이해를 위해서 하드 링크와 소프트 링크의 차이를 들자면 inode가 데이터 본체이고, 파일 A, B는 inode를 가리키는 포인터나 참조 같은 개념으로 이해하면 좀 더 이해하기 쉬울 거 같음 C의 포인터를 예로 들자면 하드링크는 동적할당한 int형 공간이 하나가 있는데 그걸 가리키는 int형 포인터가 2개라서 포인터가 하나 사라져도 다른 하나가 가리키고 있기 때문에 그대로 int형 공간을 사용할 수 있음 
반대로 소프트 링크는 동적할당한 공간이 2개가 있고, 그걸 각각의 포인터가 가리키는데 B 포인터의 공간이 포인터 A를 가리키는 것(???)이라서 A 포인터가 사라지면 A가 가리키던 int형 공간의 주소를 가지고 있는 값이 없으니까 쓸 수 없어서 할당 해제되는 그런 느낌..? 비슷한 거 같긴 하지만 잘은 모루겠음;;

**하나의 inode를 여러개의 파일이 가리키는 것은 가능하지만 반대로 하나의 파일에서 여러 개의 inode를 가리키는 것은 안 됨**


---
## 파일 링크 ##

`ln`은 **l**i**n**k의 약자로 링크 파일을 생성함. 
`ln [옵션] [원본 파일] [링크 파일]`로 실행하고 옵션은 아래와 같음

| 옵션  | 기능                                                         |
| --- | ---------------------------------------------------------- |
| -b  | 이미 생성하고자 하는 링크 파일과 동일한 이름의 파일이 존재하는 경우 백업파일을 만들고 링크파일을 생성함 |
| -d  | 디렉토리의 하드링크 파일 생성을 허용함                                      |
| -f  | 이미 생성하고자 하는 링크 파일과 동일한 이름의 파일이 존재하는 경우 기존 파일을 덮어씌움         |
| -s  | 심볼릭 링크 파일을 생성함                                             |
| -n  | 링크하고자 하는 원본 파일이 심볼릭 링크인 경우 원본 심볼릭 링크가 가리키고 있는 파일로 링크함      |
\*실습을 위해 dir1, file1을 생성함

ln file1 hardlink_file 로 하드링크 파일을 생성할 수 있음
아래는 위 명령어를 실행한 결과로 inode를 확인해보면 두 파일의 inode가 12141로 같고 file 파일의 링크 개수가 1->2로 바뀐 걸 확인할 수 있음

![[Pasted image 20260206173148.png]]


`ln -s file1 symlink_file1`로 심볼릭 링크 파일을 생성할 수 있음

아래는 위 명령어를 실행한 결과인데 `inode`를 확인해보면 하드링크한 위 그림과는 다르게 두 파일 (`file1`과 `symlink_file1`)의 `inode`가 다른 것을 확인할 수 있음
왜냐하면 syslink_file1은 따로 inode를 가리키고 있고, 그 inode가 file1을 가리키고 있기 때문

![[Pasted image 20260206173535.png]]



---
# 파일 탐색 #

## 파일 탐색(find) ##

`find`는 **find** 뜻 그대로 파일을 탐색하는 명령어임
`find [옵션] [탐색 시작 경로] [표현식 1] [표현식 2] ...` 으로 사용하며, 탐색 시작 경로부터 시작해 표현식을 만족하는 파일을 탐색함

| 옵션          | 기능                                             |
| ----------- | ---------------------------------------------- |
| -p          | 탐색 중 심볼릭 링크 파일을 만나는 경우 심볼릭 링크 자체 정보를 사용함       |
| -L          | 탐색 중 심볼릭 링크 파일을 만나는 경우 심볼릭 링크에 연결된 파일의 정보를 사용함 |
| -H          | 심볼릭 링크를 따라가지 않음                                |
| -D \[추가 옵션] | 추가 디버깅 옵션을 사용함                                 |
| -O \[Level] | 쿼리 최적화를 수행함                                    |


아래는 주로 쓰는 표현식임

| 표현식                | 기능                                               |
| ------------------ | ------------------------------------------------ |
| -name \[text]      | 파일 이름이 \[text]인 파일을 찾음                           |
| -user \[text]      | 파일의 소유자 이름이 \[text]인 파일을 찾음                      |
| -group \[text]     | 파일의 그룹 이름이 \[text]인 파일을 찾음                       |
| -uid \[uid]        | 파일의 uid가 \[uid]인 파일을 찾음                          |
| -gid \[gid]        | 파일의 gid가 \[gid]인 파일을 찾음                          |
| -perm \[permisson] | 파일의 권한이 \[permission]인 파일을 찾음                    |
| -type \[type]      | 파일의 종류가 \[type]인 파일을 찾음 (ex. `-type d`: 디렉토리 탐색) |
| -maxdepth \[depth] | 하위 디렉토리의 깊이가 \[depth] 이하인 곳까지 탐색함                |
| -mindepth \[depth] | 하위 디렉토리의 깊이가 \[depth] 이상인 곳부터 탐색함                |

\* 실습을 위해 `touch dir1/file1` 으로 `dir1`에도 `file1`을 생성함

`find . -name 'file1'` 을 입력해서 현재 디렉토리부터 모든 하위 디렉토리를 순회하면서 'file1' 이라는 이름을 가진 파일들의 경로를 출력함

![[Pasted image 20260207141959.png]]


`find . -mindepth 2 -name 'file1'` 를 입력하면 현재 디렉토리(depth = 1)를 제외하고 탐색하기 때문에 아래같은 결과가 나옴

![[Pasted image 20260207142400.png]]


반대로 `find . -maxdepth 1 -name 'file1'` 를 입력하면 현재 디렉토리(depth = 1) 까지만 탐색하기 때문에 때문에 아래같은 결과가 나옴

![[Pasted image 20260207142517.png]]


`[text]`에는 **와일드카드(Wildcard)** 를 사용할 있음. 와일드카드에 대한 세부적인 내용은 추후 배워볼 예정이며 일단 `*`는 0글자 이상의 모든 문자열과 매칭될 수 있는 와일드 카드임. 

![[Pasted image 20260207150808.png]]




---
## 키워드 ##
- ### 파일(File) ###
	- 의미가 있는 정보를 모아둔 논리적인 단위
- ### 디렉토리 ###
	- 파일을 분류하기 위해 사용하는 **네임스페이스(Namespace)** 로 다른 디렉토리 혹은 파일을 내부에 포함할 수 있으며, 이때 포함되는 디렉토리를 **하위 디렉토리(Child Directory / Sub Directory)**, 그 반대를 **상위 디렉토리(Parent Directory)** 라고함
- ### 주요 명령어 ###
	- `pwd`: 명령어를 사용하면 현재 자신의 디렉토리 위치를 알 수 있음
	- `cd`: 명령어를 사용하면 자신이 있는 디렉토리의 위치를 변경할 수 있음. 이때 인자로는 절대 경로와 상대 경로를 모두 받을 수 있음
	- `ls`: 명령어를 사용하면 지정한 경로의 디렉토리나 파일을 확인할 수 있음
	- `mkdir`: 명령어를 사용하면 새로운 디렉토리를 생성할 수 있음
	- `rmdir`: 명령어를 사용하면 생성한 디렉토리를 삭제할 수 있음
	- `touch`: 명령어를 사용하면 새로운 파일을 생성할 수 있음
	- `cat`: 명령어를 사용하면 새로운 파일을 생성하고 작성하는 것이 가능하며, 생성된 파일의 내용을 읽을 수도 있음
	- `head/tail`: 명령어를 사용하면 각각 파일의 앞과 뒤에서 내용을 읽어올 수 있음
	- `mv`: 명령어를 사용하면 파일의 위치를 이동시킬 수 있음
	- `cp`: 명령어를 사용하면 파일을 복사할 수 있음
	- `rm`: 명령어를 사용하면 파일을 삭제할 수 있음
	- `ln`: 명령어를 사용하면 하드 링크와 심볼릭 링크 파일을 생성할 수 있음
	- `find`: 명령어를 사용하면 원하는 파일의 경로를 쉽게 탐색할 수 있음



