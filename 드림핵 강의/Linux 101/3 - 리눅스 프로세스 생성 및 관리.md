# 프로세스란? #
## 프로세스 ##

**프로세스(Process)** 는 컴퓨터에서 실행되고 있는 프로그램임. 사용자 혹은 이미 실행되고 있는 프로세스가 실행 가능한 프로그램을 실행하고자 하는 경우 운영체제에 실행을 요청하여 운영체제는 이 명령을 받아 프로세스를 생성함. 생성된 프로세스는 **Central Processing Unit (CPU)** 에서 실행되며 만약 여러 프로세스가 동시에 실행되는 경우 운영체제가 적절하게 실행 순서를 조절하여 문제 없이 여러 프로세스가 동작하도록함

![[Pasted image 20260207152830.png]]

프로세스는 크게 5가지의 상태를 가짐
- **생성(Create)** : 프로세스가 생성되는 중임
- **실행(Running)** : 프로세스가 CPU를 점유하여 실제로 명령어들을 실행하는 중임
- **준비(Ready)** : 프로세스가 CPU를 점유하기 위해 대기하고 있는 상태임
- **대기(Blocked)** : 프로세스가 입출력 대기 혹은 리소스에 접근 불가 등의 이유로 요청한 일을 수행할 수 없어 CPU를 양도하고 선수 작업이 완료되기를 대기하는 상태
- **종료(Terminated)** : 프로세스가 종료되는 중임


---
## 리눅스 프로세스 ##

리눅스의 프로세스는 **Process ID (PID)** 와 **Parent Process ID (PID)** 를 가짐

**PID**는 현재 프로세스의 아이디를 의미하고 **PPID**는 부모 프로세스의 아이드를 의미함. 프로세스의 아이디는 고유함

리눅스는 새로운 프로세스를 생성할 때 `fork()`를 사용해 현재 프로세스를 복제하여 새로운 프로세스를 생성함. 이런 특징 때문에 프로세스 간 관계도를 그릴 경우 최상위 프로세스가 유일하게 존재하며 이를 **init** 프로세스라함. **init**의 **PID**는 1임

![[Pasted image 20260207153448.png]]

만약 `fork()`로 프로세스를 생성할 경우 원본 프로세스를 **부모 프로세스(Parent Process)** 라고 부르고, 생성되는 프로세스를 **자식 프로세스(Child Process)** 라고 부름

이후 `fork()`로 생성된 자식 프로세스에서 `exec()`을 사용하면, 프로세스를 복제한 후 자식 프로세스의 내용을 다른 실행파일의 내용으로 덮어쓰게 됨. 리눅스는 이와 같은 방식으로 새로운 프로그램을 실행함

부모 프로세스는 자식 프로세스를 수거할 책임이 있음. 부모 프로세스는 자신이 생성한 자식 프로세스의 종료 상태를 인지하고 자식 프로세스가 사용한 자원들을 정리할 책임이 있는 것을 의미함. 만약 자식 프로세스보다 부모 프로세스가 먼저 종료된다면 자식 프로세스는 **고아 프로세스(Orphan Process)** 가 됨. 리눅스는 이런 프로세스들의 **PPID**를 1로 변경하여 부모 프로세스를 **init**으로 변경함

반대로 자식 프로세스는 종료되었지만 부모 프로세스가 종료된 자식 프로세스를 수거하지 않아 그대로 남아있을 수 있음. 이 경우 자식 프로세스를 **좀비 프로세스(Zombie Process)** 라 부름. 일반적인 상황에서 모든 프로세스는 일시적으로 좀비 프로세스가 되었다가 부모에 의해 수거됨



---
# 프로세스 관리 #

## 프로세스 확인(ps, htop) ##

`ps`는 **p**rocess **s**tate의 약자로 현재 실행중인 상태를 보여줌. `ps [옵션]`으로 사용함

| 옵션         | 기능                                    |
| ---------- | ------------------------------------- |
| -A         | 모든 프로세스 정보를 출력함                       |
| -a         | 세션 리더를 제외한 터미널에 종속적이지 않은 모든 프로세스를 출력함 |
| -e         | 커널 프로세스를 제외한 모든 프로세스를 출력함             |
| -f         | 정보 출력 시 **풀 포맷(Full Format)** 을 사용함   |
| -l         | 정보 출력 시 **롱 포맷(Long Format)** 을 사용함   |
| -M         | 64bit 프로세스들을 출력함                      |
| -m         | 커널 스레드를 출력함                           |
| -p \[pid]  | \[pid]를 가지는 프로세스를 출력함                 |
| -r         | 현재 실행 중인 프로세스를 출력함                    |
| -u \[user] | \[user]가 실행하는 프로세스를 출력함               |

**풀 포맷** 사용 시
![[Pasted image 20260207154549.png]]

**롱 포맷** 사용 시
![[Pasted image 20260207154628.png]]

각 열의 의미 (적기 귀찮아서 스크린샷으로 대체)
![[Pasted image 20260207154902.png]]


\* 실습을 위해 ps_test.c 생성 및 컴파일을 함

![[Pasted image 20260207155620.png]]


생성한 ps_test 오브젝트를 `./ps_test`로 실행하고 `ps -u user(whoami 내용, 여기선 yu) -l` 을 실행하면 아래 결과처럼 나옴

![[Pasted image 20260207172849.png]]
위 터미널이 `ps_test`를 실행한 터미널이고, 아래가 `ps -u yu -l`을 통해서 확인한 `ps_test`임 
`ps -u yu -l`의 뜻은 `ps`: 실행중인 프로세스 표시, `-u yu`: yu라는 유저가 실행한 프로세스로 한정, `-l`: 롱 포맷으로 출력

현재 ps_test는 입력을 대기하는 상태로 이벤트가 완료되기를 대기중이어서 **State**는 S가 됨. 그리고 `ps_test`와 `ps`의 TTY값이 다른 이유는 서로 다른 터미널에서 실행했기 때문에 TTY값이 다름

![[Pasted image 20260207170902.png]]
여기서는 같은 터미널에서 했기 때문에 TTY가 같음


---
## 포그라운드와 백그라운드(fg, bg, jobs) ##

**포그라운드 프로세스(Foreground Process)** 는 사용자와 직접적으로 상호작용하며 실행되는 프로세스를 뜻함. 사용자는 해당 프로세스에 입력을 하는 등 직접적으로 상호작용을 할 수 있음

**백그라운드 프로세스(Background Process)** 는 사용자와 직접적으로 상호작용하지 않고 실행되는 프로세스임. 사용자는 해당 프로세스의 입출력을 직접적으로 제어할 수 없음

백그라운드에 있지만 실행되지 않는 경우 **정지(Stopped / Subspended)** 되어 있다 표현함. 따라서 `ps_test`를 [[#※ Ctrl+c 와 Ctrl+z의 차이점 ※|Ctrl+z]] 로 중단했다면 `ps_test`는 정지된 상태이지만 프로세스로 유지되고는 있는 상태가됨

`jobs`는 사용자가 셸을 통해 실행한 프로세스의 리스트와 그 순서를 출력함

아래 그림과 같이 `ps_test`를 중단한 터미널에서 `jobs` 명령어를 입력하면 아래와 같이 나옴. `ps_test`가 `Stopped` 상태로 있는 모습을 볼 수 있음. 앞에 있는 숫자는 현재 동작하고 있는 고유한 프로세스 순서이며 해당 숫자를 이용해 프로세스의 **포그라운드**와 **백그라운드** 상태를 조작함

![[Pasted image 20260207165957.png]]


### fg ###

`fg`는 정지된 프로세스나 백그라운드 프로세스를 포그라운드로 가져옴 `fg 1`을 입력하고 다른 터미널에서 `ps -u yu -l`를 사용하면 해당 프로세스의 상태가 T에서 S로 변경된 걸 확인할 수 있음. 이건 프로세스 상태가 포그라운드로 넘어오면서 정지상태가 풀렸기 때문임

![[Pasted image 20260207172709.png]]



### bg ###

`bg`는 정지된 프로세스를 백그라운드에서 실행하도록함. ctrl-z로 `ps_test`를 중단 상태로 만든 후, **bg 1**을 실행하면 `./ps_test &` 라는 내용이 출력됨

![[Pasted image 20260207173912.png]]

`&`는 프로세스를 백그라운드에서 실행하겠다는 뜻으로, ㅅ용자가 직접 터미널에 `./ps_test &`로 실행하는 경우 터미널은 `./ps_test`를 **포그라운드**가 아닌 **백그라운드**에서 실행함

다만 해당 프로그램의 경우 실행 중이 아닌 이벤트 대기중인 상태로 (사용자 입력 대기) 백그라운드로 넘어가더라도 계속 중단 상태에 있게 됨

\* 다른 내용도 있기는 한데 솔직히 그다지 쓸모없어 보여서 kill, pkill까지만 할 것


---
## 프로세스 종료(kill, pkill) ##

프로세스 종료는 주로 `kill` 명령을 사용함

`kill - [signal] [PID]` 로 사용하며 자주 보는 **시그널(Signal)** 종류는 다음과 같음. 시그널이란 커널이 프로세스에게 보내는 특수한 보내는 특수한 신호로써 이 신호를 받는 즉시 프로세스는 기존에 수행하던 일을 중단하고 요청받은 시그널을 우선적으로 처리해야함

**SIGKILL - 9 (프로세스를 강제로 종료함)**
이게 보편적으로 가장 많이 쓰여서 이걸 외워두면 좋음



---
# 프로그램 실행 방법 #

## 프로그램 실행 방법 ##

리눅스에서는 파일 데이터의 시작 부분에 위치한 값을 이용하여 어떤 파일인지 식별함. 파일 종류를 식별하는데에 사용되는 이 시작부분에 위치한 값을 **파일 시그너치(File Signature)** 라고 부르며, 파일 시그니처를 통해 시스템이나 프로그램이 어떤 파일이 어떤 형식인지를 자동으로 인식함. 예를 들어 실행 파일이나 이미지 파일 등은 각각 특유의 파일 시그니처를 가지고 있어서, 정확히 분류될 수 있음

셸에서 어떤 파일의 경로를 입력하였을 때 해당 파일의 파일 시그니처를 확인한 결과 **실행 가능한 파일**이면 셸은 해당 프로그램을 `exec()`로 실행함. 셸은 입력받은 프로그램의 실행을 리눅스 커널에 요청하고 커널은 이를 프로세스로 바꾸어 실행함

리눅스를 학습하면서 실행해보았을 `ls`, `cat` 등의 명령어는 사실 리눅스 파일 시스템의 `/bin/ls`, `/usr/bin/cat` 등에 위치한 실행 파일임


---
## 실행파일 생성 및 실행 ##

리눅스는 **Excutable and Linkable Format (ELF)** 형식의 실행파일을 지원함. Windows는 **PE (Portable Executable)**, macOS는 **Mach-O (Mach Object File Format)** 등 각 OS마다 지원하는 고유한 실행파일 형식이 존재하기 때문에 서로 다른 OS의 실행파일끼리는 일반적으로 호환되지 않음. 이것이 Windows의 PE 포맷 실행 파일인 `.exe`, `.dll` 들을 리눅스에서 돌릴 수 없는 이유임

실행파일을 만드는 방법 중 가장 간단한 방법은 **GCC (GNU Compiler Collection)** 와 같은 컴파일러를 이용해 코드를 실행파일로 바꾸는 것. 이 과정을 **컴파일(Compile)** 이라 부르며, 실행하기 위해 컴파일이 필요한 언어를 **컴파일 언어(Compiled Language)** 라 부르며. 대표적으로 C, C++, Go, Java, Rust 등이 있음

**컴파일** 없이 실행 가능한 언어들도 있으나 엄밀하게는 해당 언어를 실행할 수 있는 컴파일된 프로그램이 실행 코드를 한줄 한줄 해석하며 코드를 실행하는 것임.
대표적으로 Python, JavaScript 등이 있으며 이런 언어들을 **인터프리터 언어(Interpreted Lanuage)**






























#### ※ Ctrl+c 와 Ctrl+z의 차이점 ※####
> 리눅스에서 **Ctrl+c**는 실행 중인 프로세스에 `SIGINT` 신호를 보내 즉시 **종료(Kill)**하는 반면, **Ctrl+z**는 `SIGSTP` 신호를 보내 프로세스를 잠시 **중지(Suspend/Sleep)**시키고 백그라운드로 전환합니다. Ctrl+c는 작업을 완전히 끝내지만, Ctrl+z는 일시 정지 상태로 메모리에 남아 `fg` 명령어로 재개 가능합니다. 
> 
> - **Ctrl+c (Cancel/Interrupt):**
>     - 기능: 포그라운드 프로세스 즉시 종료 (SIGINT).
>     - 상태: 프로세스가 메모리에서 완전히 사라짐.
>     - 용도: 프로그램 강제 종료.
> - **Ctrl+z (Suspend/Sleep):**
>     - 기능: 포그라운드 프로세스 일시 정지 (SIGSTP).
>     - 상태: 프로세스가 백그라운드에서 중지 상태로 대기.
>     - 용도: 작업을 잠시 멈추고 다른 작업 후 `fg`로 복귀.
> 













































